#ifdef HAVE_CONFIG_H
#include "config.h"
#else
#define PACKAGE "ponga"
#define PACKAGE_STRING "ponga 0.0.0"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <assert.h>

#include "log.h"
#include "utils.h"
#include "wrapper.h"
#include "h5.h"
#include "strv.h"
#include "count_table.h"
#include "count_k_mer.h"
#include "cmp_k_mer.h"
#include "test.h"

#define DEFAULT_PREFIX "out"

struct _Test
{
	const char *h5_file;
	const char *file;
	const char *prefix;
};

typedef struct _Test Test;

static CountKMer *
retrieve_dataset (const char *file)
{
	CountKMer *ck = NULL;
	H5 *h5 = NULL;

	ck = xcalloc (1, sizeof (CountKMer));

	log_info ("Open HDF5 file '%s'", file);
	h5 = h5_open (file);

	log_info ("Read count dataset and k-mer length");
	ck->table = h5_read_count_dataset (h5, &ck->k);

	log_info ("Read label dataset");
	ck->label = h5_read_label_dataset (h5);

	h5_close (h5);

	return ck;
}

static void
run (Test *t)
{
	CountKMer *ck = NULL;

	log_info ("Retrieve datsets from '%s'", t->h5_file);
	ck = retrieve_dataset (t->h5_file);

	log_info ("Apply model to each entry at '%s'", t->file);
	cmp_k_mer (ck, t->file);

	log_info ("FINITO");
	count_k_mer_free (ck);
}

static void
print_usage (FILE *fp)
{
	fprintf (fp,
		"%s\n"
		"\n"
		"Usage: %s test [-h] [-p STR] -d <HDF5> <FILE>\n"
		"\n"
		"Output:\n"
		"   Not sure\n"
		"\n"
		"Arguments:\n"
		"   A file with two columns: CLASS and SEQ\n"
		"\n"
		"Mandatory Options:\n"
		"   -d, --h5-db             A HDF5 database with k-mer\n"
		"                           counts, generated by the\n"
		"                           command 'train'\n"
		"\n"
		"Options:\n"
		"   -h, --help              Show this help and exit\n"
		"   -p, --prefix            Prefix for the output file\n"
		"                           [default: %s]\n"
		"\n",
		PACKAGE_STRING, PACKAGE, DEFAULT_PREFIX);
}

static void
print_try_help (FILE *fp)
{
	fprintf (fp, "Try '%s test --help' for more information\n",
			PACKAGE);
}

static void
test_print (const Test *t)
{
	char buf[BUFSIZ] = {};

	snprintf (buf, BUFSIZ,
		">> Test <<\n"
		"\n"
		"#\n# %s\n#\n\n"
		"# Run %s\n"
		"$ %s Test \\\n"
		"   --h5-db='%s' \\\n"
		"   --prefix='%s' \\\n"
		"   '%s'\n",
		PACKAGE_STRING, PACKAGE, PACKAGE,
		t->h5_file, t->prefix, t->file);

	buf[BUFSIZ - 1] = '\0';
	log_info ("%s", buf);
}

static int
test_validate (Test *t)
{
	int rc = EXIT_SUCCESS;

	/*
	* Validate arguments and mandatory options
	*/

	if (t->file == NULL)
		{
			fprintf (stderr, "%s: Missing file\n", PACKAGE);
			print_try_help (stderr);
			rc = EXIT_FAILURE; goto Exit;
		}

	if (!exists (t->file))
		{
			fprintf (stderr, "%s: file '%s': No such file\n", PACKAGE, t->file);
			rc = EXIT_FAILURE; goto Exit;
		}

	if (t->h5_file == NULL)
		{
			fprintf (stderr, "%s: Missing HDF5 database\n", PACKAGE);
			print_try_help (stderr);
			rc = EXIT_FAILURE; goto Exit;
		}

	if (!exists (t->h5_file))
		{
			fprintf (stderr, "%s: HDF5 database '%s': No such file\n", PACKAGE, t->h5_file);
			rc = EXIT_FAILURE; goto Exit;
		}

Exit:
	return rc;
}

int
parse_test_command_opt (int argc, char **argv)
{
	assert (argc > 1 && argv != NULL && *argv != NULL);

	// No options or arguments
	// Print usage
	if (argc == 2)
		{
			print_usage (stdout);
			return EXIT_SUCCESS;
		}

	struct option opt[] =
	{
		{"help",    no_argument,       0, 'h'},
		{"prefix",  required_argument, 0, 'p'},
		{"h5-db",   required_argument, 0, 'd'},
		{0,         0,                 0,  0 }
	};

	Test t = {.prefix = DEFAULT_PREFIX};
	int rc = EXIT_SUCCESS;
	int option_index = 0;
	int c;

	while ((c = getopt_long (argc, argv, "hp:d:", opt, &option_index)) >= 0)
		{
			switch (c)
				{
				case 'h':
					{
						print_usage (stdout);
						goto Exit;
						break;
					}
				case 'p':
					{
						t.prefix = optarg;
						break;
					}
				case 'd':
					{
						t.h5_file = optarg;
						break;
					}
				case '?':
				case ':':
					{
						print_try_help (stderr);
						rc = EXIT_FAILURE; goto Exit;
						break;
					}
				}
		}

	// Get file as arg
	t.file = argv[optind + 1];

	// Validate options
	rc = test_validate (&t);

	// If no error
	if (rc == EXIT_SUCCESS)
		{
			/*
			* RUN FOOLS
			*/
			test_print (&t);
			run (&t);
		}

Exit:
	return rc;
}
